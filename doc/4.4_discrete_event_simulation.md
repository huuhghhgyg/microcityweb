[< 4.3 Scene and Object](4.3_scene_and_object.md) | [Table of Contents](readme.md) | [4.5 Mixed Integer Programming >](4.5_mixed_integer_programming.md)

# 4.4 Discrete Event Simulation
In simulation, events need to be randomly generated and scheduled, so the random number and coroutine functions in Lua have been improved.

## Random Number Generation
The probability distribution of random numbers has been expanded, but the traditional usage is still maintained.

<a id='math.randomseed'> math.randomseed (x, [, disttab]) </a>

Return a seed according to the integer parameters x and the optional table of disttab. The options in disttab:
- dist: Probability distribution, one of "normal", "exponential", "poisson" and "uniform". Default is "uniform".
- mu: Mean or expected value. Default is 1.
- sigma: Standard deviation (only applicable for normal distribution). Default is 1.

<a id='math.random'> math.random ([seed|m [, n]]) </a>

When called without arguments, returns a uniform real number in the range [0,1). When called with an integer number m, returns a uniform integer in the range [1, m]. When called with two integer numbers m and n, returns a uniform integer in the range [m, n].
<br>When called with a **seed** generated from math.randomseed, returns a number follow the distribution specified by the seed. This usage can be rewritten to seed:random(). An example is shown below:
```
local seed = math.randomseed(1, {dist = "normal", mu = 5, sigma = 3})
for i = 1, 10 do
    print(seed:random())
end
```

## Event Scheduling
In discrete event simulation, events need to be scheduled in chronological order. In MicroCity Web, events are defined as Lua's coroutine (or function), so three new members are added to the coroutine library.

<a id='coroutine.queue'> coroutine.queue (rt, f|co [, arg1, ···]) </a>

Queue an event f (function) or co (coroutine) by relative time rt (>=0) for later execution. The values arg1, ... are passed as the arguments to the body function. 

<a id='coroutine.qtime'> coroutine.qtime () </a>

Return the current simulation time (queued time).

<a id='coroutine.qexec'> coroutine.qexec () </a>

Execute all events in chronological order. By default MicroCity Web will run this function at the end of script, but user can explicitly call it when necessary.

## Simulating a M/M/1 Queue

To demonstrate these functions here use the <a href="https://en.wikipedia.org/wiki/M/M/1_queue" target="_blank">M/M/1 queue</a> as an example:

A queuing system reaches a customer on average every 3 minutes, and the server serves a customer within 2.5 minutes on average. First come, first served. An <a herf="https://en.wikipedia.org/wiki/Event_relationship_graph" target="_blank">Event Relationship Graph</a> can be drawn here:

![](./img/mm1.svg)

And the source code:

```
local M = "Idle"                                                            --init the server
local Q = 0                                                                 --init the queue
local arrival_time = math.randomseed(1, {dist = "exponential", mu = 3})     --arrival time random seed
local service_time = math.randomseed(1, {dist = "exponential", mu = 2.5})   --service time random seed

function Arrive()                                                           --arrive event
    Q = Q + 1                                                               --queue increment
    local ta = arrival_time:random()                                        --get next arrive event
    coroutine.queue(ta, Arrive)                                             --schedule the next arrive event
    if M == "Idle" then                                                     --check the server
        coroutine.queue(0, Start)                                           --start service
    end

    local t = coroutine.qtime()                                             --get current simulation time
    print("Customer arrive at time: ", t, " Q = ", Q)                       
end

function Start()                                                            --start event
    M = "Busy"                                                              --set the server to busy
    Q = Q - 1                                                               --queue decrement
    local ts = service_time:random()                                        --get a service time
    coroutine.queue(ts, Leave)                                              --schedule the leave event

    local t = coroutine.qtime()                                             --get current simulation time
    print("Service start at time: ", t, " Q = ", Q)
end

function Leave()                                                            --leave event
    M = "Idle"                                                              --set the server to idle
    if Q > 0 then                                                           --if find one more customer
        coroutine.queue(0, Start)                                           --start service
    end

    local t = coroutine.qtime()                                             --get current simulation time
    print("Customer leave at time: ", t, " Q = ", Q)    
end

coroutine.queue(0, Arrive)                                                  --schedule the first arrive event

```

[< 4.3 Scene and Object](4.3_scene_and_object.md) | [Table of Contents](readme.md) | [4.5 Mixed Integer Programming >](4.5_mixed_integer_programming.md)